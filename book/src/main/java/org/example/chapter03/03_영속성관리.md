# Chpater 3. 영속성 관리


## 엔티티 매니저 팩토리
- `엔티티 매니저 팩토리`는 `엔티티 매니저`를 만든다.
  - persistence 설정 정보 (persistence.xml) 을 읽어서 JPA 기반 객체를 생성한다.
  - 이름 그대로 공장에서 `엔티티 매니저`를 찍어내듯이 생성한다. 
- `엔티티 매니저 팩토리`는 비싼 편이기 때문에 한 개만 만들어서 어플리케이션 전체에 공유하도록 설계되어 있다.
  - `엔티티 매니저 팩토리`를 생성할 때 데이터베이스 커텍션 풀도 생성하므로 `엔티티 매니저 팩토리`를 생성하는 비용은 비싼편이다.
  - 따라서 엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다.
- 여러 스레드가 동시에 접근해도 안전하다.

## 엔티티 매니저
- `엔티티 매니저`는 엔티티를 저장, 조회 등 엔티티 관련된 작업을 처리하고 관리한다.
- 여러 스레드가 동시에 접근하면 동시성 문제가 발생
- `엔티티 매니저`는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다. (트랜잭션을 시작할 때 커넥션을 획득한다.)

<br>
<br>

## 영속성 컨텍스트
- 엔티티를 저장하는 환경으로써, 엔티티 매니저를 통해 저장 조회 등의 처리를 한다면 앤티티 매니저는 `영속성 컨텍스트`에 엔티티를 저장한다.
- em.persist();
  - 엔티티 매니저를 사용하여 엔티티를 `영속성 컨텍스트`에 저장한다.
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다.
- 여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수 있다.

## 엔티티 생명 주기

  ![state.png](img%2Fstate.png)

- 비영속 (new / transient)
  - 엔티티 생성 직후 저장하지 않은 상태, 영속성 컨텍스트나 DB와 관련이 없는 상태
- 영속 (managed)
  - 영속성 컨텍스트에 저장된 상태, 영속성 컨텍스트에 의해 관리되는 상태
  - em.find() or JPQL로 조회한 엔티티도 영속 상태이다.
- 준영속 (detached)
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
  - close()를 호출해서 영속성 컨텍스트를 닫거나 clear()를 호출해서 영속성 컨텍스트를 초기화하면 준영속 상태가 된다.
- 삭제 (removed)
  - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제된 상태

## 영속성 컨텍스트의 특징
- 영속성 컨텍스트와 식별자 값
  - 영속성 컨텍스트는 엔티티를 식별자로 구분한다.
  - 영속 상태는 식별자 값이 반드시 존재하여야 한다.
- 영속성 컨텍스트와 데이터베이스 저장
  - 영속 상태인 엔티티는 언제 DB에 저장될까?
  - 트랜잭션을 커밋하는 순간 영속 상태인 엔티티를 DB에 반영한다. 이를 flush 라고 한다.

## 영속성 컨텍스트의 장점
### 1. 1차 캐시
- 영속성 컨텍스트는 내부에서 캐시를 가지는데 이를 1차 캐시라고 한다.
- 영속 상태의 엔티티는 모두 캐시에 저장된다.
- 캐시 key는 @Id로 매핑한 식별자이고 value는 엔티티 인스턴스이다.
  - 영속성 컨텍스트에 저장하고 조회하는 모든 기준은 DB 기본 키 값이다.
  ```java
  // EntityManager.find()
  public <T> T find(Class<T> entityClass, Object primaryKey);
  ```
- find()를 호출하면 1차 캐시에서 조회하고 없으면 DB에서 조회한다.
  - DB에서 조회후 1차 캐시에 저장한 후 엔티티를 반환한다.
- 조회시 성능상 이점을 볼 수 있다.
- 반복 가능한 읽기 (Repeatable Read) 등급의 트랜잭션 격리 수준을 어플리케이션 차원에서 제공하는 장점이 있다.

### 2. 동일성 보장
- 식별자가 같은 영속 상태의 엔티티를 조회해서 비교하면 같은 인스턴스를 반환한다.
  - 동일성 : 실제 인스턴스가 같다. == 비교 값이 true라는 말
  - 동등성 : 실제 인스턴스가 다르다. 인스턴스가 가지고 있는 값들이 같다.

### 3. 트랜잭션을 지원하는 쓰기 지연
- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 영속성 컨텍스트의 내부 쿼리 저장소에 C,U,D SQL을 저장한다.
  - 커밋시 flush()를 하게 되며 이때 모아둔 쿼리를 DB에 전송, 이것을 쓰기 지연이라고 한다.
  - 플러시는 영속성 컨텍스트의 변경 내용(C,U,D)을 DB에 동기화하는 작업
- 이 기능을 잘 활용하면 성능을 최적화할 수 있다.

### 4. 변경 감지
- 엔티티를 수정할 때는 단순하게 조회된 엔티티의 데이터만 변경하면 된다.
- 엔티티의 변경사항을 DB에 자동으로 반영하는 기능을 변경 감지 (dirty checking)이라고 한다.
- 엔티티를 영속화할 때 최초 상태를 스냅샷을 복사하여 저장해둔다.
- 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티가 있으면 수정 쿼리를 생성하여 쓰기 지연을 활용한다.
- 변경 감지는 영속 상태의 엔티티만 적용된다.

<br>

- 변경 감지를 조심히 사용해야하는데, 수정된 데이터만 반영되는 것이 아닌 모든 필드를 반영한다.
- 이로인해 DB에 flush() 할 때 데이터 전송량이 증가하는 단점이 있지만 다음과 같은 장점들도 있다.
1. 모든 필드를 반영한다면, 바인딩 되는 데이터 외에 수정 쿼리가 항상 같기 때문에 어플리케이션 런타임 시점에 수정 쿼리를 미리 생성하고 재사용할 수 있다.
2. DB 또한 한번 파싱된 쿼리를 재사용할 수 있다.
- 만약 너무 많은 필드를 다뤄야 한다면 하이버네이트 확장 기능인 @DynamicUpdate 사용하여 수정된 데이터만 동적으로 SQL을 생성하게 할 수 있다.
  - 존재하는 데이터만 생성하는 @DynamicInsert도 있다.
- 만약 컬럼이 30개 이상이면 @DynamicUpdate를 사용하는 방법이 빠르다고 한다.
- 